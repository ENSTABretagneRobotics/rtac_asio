/**
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */



#ifndef _DEF_RTAC_ASIO_STREAM_H_
#define _DEF_RTAC_ASIO_STREAM_H_

#include <chrono>
#include <mutex>
#include <condition_variable>

#include <rtac_asio/AsyncService.h>
#include <rtac_asio/StreamInterface.h>

namespace rtac { namespace asio {

class Stream
{
    public:

    using ErrorCode = StreamInterface::ErrorCode;
    using Callback  = StreamInterface::Callback;

    using Timer  = boost::asio::deadline_timer;
    using Millis = boost::posix_time::milliseconds;

    struct Request {
        uint64_t  requestId;
        int64_t   requestedSize;
        int64_t   processed;
        Callback  handler;

        Timer timer;

        std::mutex mutex;
        bool waiterNotified;
        std::condition_variable waiter;

        Request(AsyncService::Ptr service) :
            timer(service->service())
        {}
        
        int64_t remaining() const { return requestedSize - processed; }
    };

    struct ReadRequest : public Request {
        ReadRequest(AsyncService::Ptr service) : Request(service) {}
        uint8_t* data;
    };

    struct WriteRequest : public Request {
        WriteRequest(AsyncService::Ptr service) : Request(service) {}
        const uint8_t* data;
    };

    protected:

    StreamInterface::ConstPtr stream_;

    mutable ReadRequest  readRequest_;
    mutable std::size_t  lastReadRequestId_;
    mutable WriteRequest writeRequest_;
    mutable std::size_t  lastWriteRequestId_;

    void read_request_continue(std::size_t requestId,
                               const ErrorCode& err, std::size_t readCount) const;
    void read_timeout(std::size_t readRequest, const ErrorCode& err) const;
    void read_continue(const ErrorCode& err, std::size_t writtenCount) const;
    void write_request_continue(std::size_t requestId,
                                const ErrorCode& err, std::size_t writtenCount) const;
    void write_timeout(std::size_t readRequest, const ErrorCode& err) const;
    
    public:

    Stream(StreamInterface::ConstPtr stream);

    void async_read_some(std::size_t count, uint8_t* data,
                         Callback callback) const;
    void async_write_some(std::size_t count, const uint8_t* data,
                          Callback callback) const;

    void async_read(std::size_t count, uint8_t* data, Callback callback,
                    unsigned int timeoutMillis = 0) const;
    void async_write(std::size_t count, const uint8_t* data, Callback callback,
                     unsigned int timeoutMillis = 0) const;

    //std::size_t read(std::size_t count, uint8_t* data) const;
    std::size_t read(std::size_t count, uint8_t* data,
                     int64_t timeoutMillis = 0) const;
    

};

} //namespace asio
} //namespace rtac

#endif //_DEF_RTAC_ASIO_STREAM_H_
