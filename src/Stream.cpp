/**
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */



#include <rtac_asio/Stream.h>

using namespace std::placeholders;

namespace rtac { namespace asio {

Stream::Stream(StreamInterface::ConstPtr stream) :
    stream_(stream)
{}

void Stream::async_read_some(std::size_t count,
                             uint8_t* data,
                             Callback callback) const
{
    stream_->async_read_some(count, data, callback);
}

void Stream::async_write_some(std::size_t count,
                              const uint8_t* data,
                              Callback callback) const
{
    stream_->async_write_some(count, data, callback);
}

void Stream::async_read(std::size_t count, uint8_t* data, Callback callback) const
{
    readRequest_.requestedSize = count;
    readRequest_.processed     = 0;
    readRequest_.data          = data;
    readRequest_.handler       = callback;
    
    stream_->async_read_some(count, data,
        std::bind(&Stream::read_request_continue, this, _1, _2));
}

void Stream::read_request_continue(const ErrorCode& err, std::size_t readCount) const
{
    readRequest_.processed += readCount;
    if(!err && readRequest_.remaining() > 0) {
        stream_->async_read_some(readRequest_.remaining(),
                                 readRequest_.data + readRequest_.processed,
                                 std::bind(&Stream::read_request_continue, this, _1, _2));
    }
    else {
        readRequest_.handler(err, readRequest_.processed);
    }
}

void Stream::async_write(std::size_t count, const uint8_t* data, Callback callback) const
{
    writeRequest_.requestedSize = count;
    writeRequest_.processed     = 0;
    writeRequest_.data          = data;
    writeRequest_.handler       = callback;
    
    stream_->async_write_some(count, data,
        std::bind(&Stream::write_request_continue, this, _1, _2));
}

void Stream::write_request_continue(const ErrorCode& err, std::size_t writtenCount) const
{
    writeRequest_.processed += writtenCount;
    if(!err && writeRequest_.remaining() > 0) {
        stream_->async_write_some(writeRequest_.remaining(),
                                  writeRequest_.data + writeRequest_.processed,
                                  std::bind(&Stream::write_request_continue, this, _1, _2));
    }
    else {
        writeRequest_.handler(err, writeRequest_.processed);
    }
}

// std::size_t Stream::read(std::size_t count, uint8_t* data) const
// {
// }
// 
// std::size_t Stream::read(std::size_t count, uint8_t* data, int64_t timeoutMillis) const
// {
//     std::unique_lock<std::mutex> lock(mutex_);
// 
//     waiterNotified_ = false;
//     this->async_read(count, data);
//     // This will wait until timeout is reached. Condition is false if timeout
//     // is reached. Return true if waiter was notified from another thread.
//     // The callback called is a protection from spurious wakes up.
//     // See std::condition_variable::wait_for documentation for more info.
//     if(!waiter_.wait_for(lock, std::chrono::milliseconds(timeoutMillis),
//                          [&]{ return waiterNotified_; })
//     {
//         std::cerr << "Timeout reached on read" << std::endl;
//     }
//     return readRequest_.processed;
// }

} //namespace asio
} //namespace rtac
